// Generated by CoffeeScript 1.7.1
(function() {
  var $, builder, cardsPath, costToColors, entities, fetchSpoilers, find, fs, getWithRedirect, http, loadDatabase, loadFile, log, mergeSpoilers, parseCost, parseDoc, parsePT, parsePicUrl, parseSpoiler, parseText, parseType, parseXML, parser, q, setLongName, setName, spoilerUrl, unique, xml2js;

  $ = require('jquery');

  http = require('http');

  xml2js = require('xml2js');

  entities = require('entities');

  fs = require('fs');

  q = require('q');

  parser = new xml2js.Parser({
    trim: true
  });

  builder = new xml2js.Builder();

  setName = process.argv[2];

  setLongName = process.argv[3];

  spoilerUrl = process.argv[4];

  cardsPath = process.argv[5];

  unique = function(array) {
    var arr;
    arr = [];
    array.forEach(function(item) {
      if ((arr.indexOf(item)) < 0) {
        return arr.push(item);
      }
    });
    return arr;
  };

  find = function(array, tester) {
    var item, _i, _len;
    for (_i = 0, _len = array.length; _i < _len; _i++) {
      item = array[_i];
      if (tester(item)) {
        return item;
      }
    }
  };

  log = function(message) {
    return function(data) {
      console.log(message);
      return data;
    };
  };

  parseDoc = function(html) {
    return {
      set: {
        name: [setName],
        longname: [setLongName]
      },
      cards: $(html).find('.t-spoiler').map(function() {
        return parseSpoiler(this);
      }).toArray()
    };
  };

  parseCost = function(elem) {
    return $(elem).find('.t-spoiler-mana > li > span').text();
  };

  parseType = function(elem) {
    return $(elem).find('.t-spoiler-type').text();
  };

  parsePT = function(elem) {
    return $(elem).find('.t-spoiler-stat').text();
  };

  parsePicUrl = function(elem) {
    return $(elem).find('a.spoiler-image-link').attr('href');
  };

  parseText = function(elem) {
    return $(elem).find('.t-spoiler-ability').find('.mana-icon').replaceWith(function() {
      return '{' + $(this).text() + '}';
    }).end().text().split('\n').map(function(str) {
      return str.trim();
    }).filter(function(str) {
      return !str.match(/^$/);
    }).join('\n');
  };

  costToColors = function(cost) {
    return unique(cost.split('').filter(function(elem) {
      return /[WUBRG]/.test(elem);
    }));
  };

  parseSpoiler = function(elem) {
    var colors, cost, name, picURL, result, text, type;
    name = elem.id;
    cost = parseCost(elem);
    colors = costToColors(cost).map(function(color) {
      return {
        '_': color
      };
    });
    type = parseType(elem);
    text = parseText(elem);
    picURL = parsePicUrl(elem);
    result = {};
    result.name = [name];
    result.set = [
      {
        '_': setName
      }
    ];
    if (picURL != null) {
      result.set[0]['$'] = {
        picURL: picURL
      };
    }
    if (colors.length > 0) {
      result.color = colors;
    }
    result.manacost = [cost];
    result.type = [type];
    if (type.match(/Planeswalker/)) {
      result.tablerow = ['1'];
      result.loyalty = [(parsePT(elem)).split('/')[1]];
    } else if (type.match(/Land/)) {
      result.tablerow = ['0'];
    } else if (type.match(/(Instant)|(Sorcery)/)) {
      result.tablerow = ['3'];
    } else if (type.match(/Creature/)) {
      result.tablerow = ['2'];
      result.pt = [parsePT(elem)];
    } else {
      result.tablerow = ['1'];
    }
    if (text.match(new RegExp(name + ' enters the battlefield tapped'))) {
      result.cipt = ['1'];
    }
    result.text = [text];
    return result;
  };

  mergeSpoilers = function(spoilers, database) {
    var db_cards, db_sets, toAdd;
    db_cards = database.cockatrice_carddatabase.cards[0].card;
    db_sets = database.cockatrice_carddatabase.sets[0].set;
    if (!find(db_sets, function(set) {
      return set.name[0] === spoilers.set.name[0];
    })) {
      db_sets.push(spoilers.set);
    }
    toAdd = spoilers.cards.filter(function(card) {
      var found;
      found = find(db_cards, function(found_card) {
        return card.name[0] === found_card.name[0];
      });
      if (found) {
        if (!find(found.set, function(set) {
          return set['_'] === spoilers.set.name[0];
        })) {
          found.set.push(card.set[0]);
        }
        return false;
      } else {
        return true;
      }
    });
    Array.prototype.push.apply(db_cards, toAdd);
    return builder.buildObject(database);
  };

  loadFile = function(path) {
    var def;
    def = q.defer();
    fs.readFile(path, function(err, data) {
      if (err) {
        return def.reject(err);
      } else {
        return def.resolve(data);
      }
    });
    return def.promise;
  };

  parseXML = function(xml) {
    var def;
    def = q.defer();
    parser.parseString(xml, function(err, data) {
      if (err) {
        return def.reject(err);
      } else {
        return def.resolve(data);
      }
    });
    return def.promise;
  };

  getWithRedirect = function(url) {
    var def;
    def = q.defer();
    http.get(url, function(resp) {
      var result;
      if (resp.statusCode === 302) {
        return getWithRedirect(resp.headers['location']).then(function(gotten) {
          return def.resolve(gotten);
        })["catch"](function(err) {
          return def.reject(err);
        });
      } else {
        result = '';
        resp.on('data', function(data) {
          return result += data;
        });
        resp.once('end', function() {
          return def.resolve(result);
        });
        return resp.once('error', function(err) {
          return def.reject(err);
        });
      }
    });
    return def.promise;
  };

  fetchSpoilers = getWithRedirect(spoilerUrl).then(log('* Fetched ' + spoilerUrl + ' ...')).then(parseDoc).then(log('* Generated card information from the website ...'));

  loadDatabase = loadFile(cardsPath).then(log('* Loaded ' + cardsPath + ' ...')).then(parseXML).then(log('* Parsed the card database ...'));

  q.all([fetchSpoilers, loadDatabase]).spread(mergeSpoilers).then(log('* Merged the fetched cards into the database ...')).then(function(data) {
    return fs.writeFileSync(cardsPath, data);
  }).then(log('* Wrote the file to disk ...')).fail(console.log).done(function() {
    console.log('* Done!');
    return process.exit();
  });

}).call(this);
